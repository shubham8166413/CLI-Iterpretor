for i in {1..5}; do
  echo "--- Run $i ---"
  npx ts-node src/index.ts --file leads.csv
  echo ""
done



it('should NOT retry on 400 (bad request) and throw immediately', async () => {
      const error = new Error('Bad request') as Error & { response?: { status: number }; isAxiosError?: boolean };
      error.response = { status: 400 };
      error.isAxiosError = true;

      mockedAxios.post.mockRejectedValueOnce(error);

      const newLead: Lead = {
        name: 'Test',
        email: 'invalid',
        company: 'Test',
        source: 'LinkedIn',
      };

      await expect(create(newLead)).rejects.toThrow('Bad request');

      expect(mockedAxios.post).toHaveBeenCalledTimes(1);
    });


What was happening:
The test was checking if create() throws an error when the API returns a 400 status.
But Jest kept saying "Received function did not throw" even though the error WAS being thrown.

The root cause:
When you mock axios to reject with an error, you were using a plain JavaScript object:

Jest's rejects.toThrow() expects a real Error instance (created with new Error()),
not a plain object. When you throw a plain object, toThrow() doesn't recognize it as a "throw".

Create an actual Error object and add the axios properties to it:


ERROR for apiCLient

BEFROE
return response.data as Lead;


AFTER (lookup)
if (response.data.found === false) {
  return null;
}
return response.data.lead as Lead;  // 

BEFROE: (create/update)
return validateLeadResponse(response.data, 'create');


AFTER (create/update (after):)
const leadData = response.data?.lead || response.data;  // âœ… Extract .lead if present
return validateLeadResponse(leadData, 'create');



-Response parsing:
  - lookup: GET /api/leads/lookup
    -> Server returns: { found: boolean, lead?: Lead }
    -> If found=false, return null
    -> If found=true, return response.data.lead (not response.data)
  
  - create: POST /api/leads/create  
    -> Server returns: { success: boolean, lead: Lead }
    -> Return response.data.lead (not response.data)
  
  - update: POST /api/leads/update
    -> Server returns: { success: boolean, lead: Lead }
    -> Return response.data.lead (not response.data)






for i in $(seq 1 20); do
  curl -s -o /dev/null -w "Request $i: HTTP %{http_code}\n" \
    "http://localhost:3001/api/leads/lookup?email=test@test.com"
done


for i in {1..20}; do 
  curl -s -X POST "http://localhost:3001/api/leads/create" \
    -H "Content-Type: application/json" \
    -d "{\"name\":\"Test $i\",\"email\":\"test$i-$RANDOM@example.com\",\"company\":\"Corp\",\"source\":\"LinkedIn\"}"
  echo ""
done
